import 'package:flutter/material.dart';
import 'package:payments_tracker_flutter/database/tables/account_table.dart';
import 'package:payments_tracker_flutter/database/tables/transaction_table.dart';
import 'package:payments_tracker_flutter/global_variables/chosen_account.dart';
import 'package:payments_tracker_flutter/models/account_model.dart';
import 'package:payments_tracker_flutter/widgets/account_card.dart';
import 'package:payments_tracker_flutter/screens/main_screen.dart';
// Import your database helper here
import 'package:payments_tracker_flutter/database/database_helper.dart';

class ChooseAccountScreen extends StatefulWidget {
  const ChooseAccountScreen({Key? key}) : super(key: key);

  @override
  State<ChooseAccountScreen> createState() => _ChooseAccountScreenState();
}

class _ChooseAccountScreenState extends State<ChooseAccountScreen> {
  List<AccountModel> _accounts = []; // Initialize with an empty list

  final TextEditingController _editAccountNameController = TextEditingController();
  final TextEditingController _accountNameController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadAccounts(); // Load accounts from database
  }

  Future<void> _loadAccounts() async {
    // Fetch accounts from your database and update the state
    final accounts = await AccountTable.getAll();
    if (mounted) { // Check if the widget is still in the tree
      setState(() {
        _accounts = accounts;
      });
    }
  }



  void _onAccountTap(AccountModel account) {
    ChosenAccount().account = account;
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const MainScreen()),
    ).then((_) {
      // Refresh accounts when returning from MainScreen
      _loadAccounts();
    });
  }

  Future<void> _showAddAccountDialog() async {
    _accountNameController.clear(); // Clear previous input
    return showDialog<void>(
      context: context,
      barrierDismissible: false, // User must tap button!
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Add New Account'),
          content: SingleChildScrollView(
            child: ListBody(
              children: <Widget>[
                TextField(
                  controller: _accountNameController,
                  decoration: const InputDecoration(hintText: "Account Name"),
                  autofocus: true,
                ),
              ],
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: const Text('Add'),
              onPressed: () async {
                final String name = _accountNameController.text.trim();
                if (name.isNotEmpty) {

                  final newAccountModel = AccountModel(name: name); // Assuming id is auto-generated by DB
                  final newAccountId = await AccountTable.insert(newAccountModel);


                  if (mounted) {
                     _loadAccounts(); // Reload accounts to get the new one with its DB ID
                     Navigator.of(context).pop();
                  }
                }
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _showEditAccountDialog(AccountModel account) async {
    _editAccountNameController.text = account.name; // Pre-fill with current name
    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Edit Account Name'),
          content: SingleChildScrollView(
            child: ListBody(
              children: <Widget>[
                TextField(
                  controller: _editAccountNameController,
                  decoration: const InputDecoration(hintText: "New Account Name"),
                  autofocus: true,
                ),
              ],
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: const Text('Save'),
              onPressed: () async {
                final String newName = _editAccountNameController.text.trim();
                if (newName.isNotEmpty && newName != account.name) {
                  final updatedAccount = AccountModel(id: account.id, name: newName);
                  await AccountTable.update(updatedAccount);
                  if (mounted) {
                    _loadAccounts(); // Reload accounts to reflect changes
                    Navigator.of(context).pop();
                  }
                } else if (newName.isEmpty) {
                  // Optionally, show an error if the name is empty
                  Navigator.of(context).pop(); // Or just close
                } else {
                  Navigator.of(context).pop(); // Name didn't change, just close
                }
              },
            ),
          ],
        );
      },
    );
  }

  @override
  void dispose() {
    _accountNameController.dispose();
    _editAccountNameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Choose Account'),
      ),
      body: ListView.builder(
        itemCount: _accounts.length,
        itemBuilder: (context, index) {
          final account = _accounts[index];
          return FutureBuilder<double>(
            future: TransactionTable.getTodayBalanceForAccount(account.id),
            builder: (BuildContext context, AsyncSnapshot<double> snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(child: CircularProgressIndicator()); // Or some placeholder
              } else if (snapshot.hasError) {
                return Text('Error: ${snapshot.error}'); // Handle error
              } else {
                // Data is loaded, build the AccountCard
                return AccountCard(
                  account: account,
                  balance: snapshot.data ?? 0.0, // Use the fetched balance
                  onTap: () => _onAccountTap(account),
                  onEditPressed: () {
                    _showEditAccountDialog(account);
                  },
                  onDeletePressed: () async {
                    // Show confirmation dialog before deleting
                    final bool? confirmDelete = await showDialog<bool>(
                      context: context,
                      builder: (BuildContext context) {
                        return AlertDialog(
                          title: const Text('Confirm Delete'),
                          content: Text('Are you sure you want to delete the account "${account.name}" and all its transactions? This action cannot be undone.'),
                          actions: <Widget>[
                            TextButton(
                              child: const Text('Cancel'),
                              onPressed: () {
                                Navigator.of(context).pop(false);
                              },
                            ),
                            TextButton(
                              child: const Text('Delete', style: TextStyle(color: Colors.red)),
                              onPressed: () {
                                Navigator.of(context).pop(true);
                              },
                            ),
                          ],
                        );
                      },
                    );
                    bool accountHasTransactions = await TransactionTable.getTransactionsCountForAccount(account.id) > 0;
                    if (confirmDelete == true && !accountHasTransactions) {
                      await AccountTable.delete(account.id!);
                      if (mounted) _loadAccounts(); // Refresh the list
                    } else if (confirmDelete == true && accountHasTransactions) {
                      // If the user confirmed delete but the account has transactions, show a message.
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text(
                                'Account "${account.name}" cannot be deleted because it has transactions. Please delete all transactions first.'),
                            backgroundColor: Colors.red,
                          ),
                        );
                      }
                    } else if (confirmDelete == false && accountHasTransactions) {
                      // User cancelled delete, and it has transactions (optional: show a different message or do nothing)
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Delete operation cancelled. Account has transactions.'),
                          ),
                        );
                      }
                    }
                  },
                );
              }
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showAddAccountDialog,
        tooltip: 'Add Account',
        child: const Icon(Icons.add),
      ),
    );
  }
}
